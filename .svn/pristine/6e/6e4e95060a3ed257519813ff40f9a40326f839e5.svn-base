#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
import ctypes

def Mbox(title, text, style):
    return ctypes.windll.user32.MessageBoxW(0, text, title, style)

from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use("TkAgg")
import os
import tkinter as tk
from tkinter import filedialog
from tkinter import DISABLED, NORMAL
from tkinter import TOP, LEFT, RIGHT, BOTTOM, CENTER
from PIL import ImageTk
import tkinterdnd2 as tkd
from CorruptedException import CorruptedFileException
from Image import Parser, Image, check_extension, Saver
from Histogram import Histogram, ColorHistogram, GreyHistogram
from tkinter import ttk
from CLI import CLI
from Database import Database
from re import match
import pickle
from datetime import datetime

BLANK_FIG = Figure()
DEFAULT_DND_CANVAS_IMAGE = "options/defaultdndtext.jpg"

if sys.version_info < (3,7):
    print("This program runs under python 3.7 or more. To use it please get"+
          " you version of python up to date.")
    Mbox("Errors", "This program runs under python 3 or more. To use it"+
         " please get you version of python up to date.")

class CanvasDnD(tk.Canvas):
    """
    ===========================================================================
    This class inherits from the tkinter class Canvas.
    It is supposed to be used with a drag and drop module for tkinter.
    ===========================================================================
    """
    def load_image_drop(self, event, app) -> None:
        """
        =======================================================================
        This method get a file contained in a related event and pass it on to
        the load_image_file method.
        =======================================================================
        Arguments:
            event: The event that led to the call of this method
            app: The application calling this method
            
        Calls:
            self.load_image_file
        """
        filename = str(event.data).replace("{", "").replace("}", "")
        self.load_image_file(filename, app);
        
    def _check_file(file, check_extension_method = check_extension,
                    error_message_type = "image", 
                    open_method = lambda x:Image(x).getimg(),
                    verify_method = lambda x:x.verify()) -> bool:
        """
        =======================================================================
        This method checks the file it has been given as argument.
        It verifies it the file is corrupted or not and if the extension
        correspond to the 
        =======================================================================
        Arguments:
            file: The name of the file containing the valued data (default: 
                                                                   the image)
                
            check_extension_method: The method to check if the file correspond
            to an accepted extension (default: Image).The default value is
            the check_extension function in the module Image.
            
            error_message_type: Indicate what type the object is supposed to be
            and will change the message in the error raised if the extension
            does not match. The default value is image.
            
            open_method: Is the function used to open the type of file needed
            The default value is Image(x).getimg().
            
            verify_method: The function used to verify the integrity of the
            file. The default value it is the verify method of the PIL.Image 
            class.
        
        Calls:
            check_extension_method,
            open_method,
            verify_method
            
        Returns:
            True is the extension matches the task and the file passed the
            verify method.
            
        Raises:
            CorruptedFileException if the files does not pass the verify_method
        """
        assert check_extension_method(file), {"The extension of the file"+
                                       " does not corresponds to a(n) "+
                                       f"{error_message_type}"
                                       " extension."}.pop()
        try:
            with open_method(file) as img:
                verify_method(img)
            return(True)
        except:
            raise CorruptedFileException("The file given seems corrupted.")
    
    def load_image_file(self, Sfile, app):
        """
        =======================================================================
        This method is called by load_image_drop and load_image_selection.
        It is the one really checking the validity of the task and opening the
        file into an Image object. It also creates a "thumbnail" by scaling the
        Image using Parser.scale_image to display on the canvas on the GUI.
        =======================================================================
        Arguments:
            Sfile: The path of the file to open.
            
            app: The Application object calling this method.
        Calls:
            CanvasDnD._check_file,
            Application.show_exception,
            Parser.scale_image,
            self.config,
            self.create_image
            Applcation.show_hist1
        """
        try:
            CanvasDnD._check_file(Sfile)
        except CorruptedFileException as ce:
            app.show_exception(ce)
        app.cli._args.image = Image(Sfile)
        self.img = Image(Sfile)
        tkimg = Parser.scale_image(self.img)
        self.tkImg = ImageTk.PhotoImage(tkimg)
        self.config(height = self.tkImg.height(), width = self.tkImg.width())
        self.create_image(self.tkImg.width(), self.tkImg.height(), 
                          image = self.tkImg, anchor = tk.SE)
        app.histCheck.configure(state = "normal")
        app.show_hist1()
    
    def load_image_selection(self, app):
        """
        =======================================================================
        This method is the one used by the button open (for the files)
        on the GUI.
        It opens a window allowing the user to browse its file and then reads 
        and load the selected file.
        =======================================================================
        Calls:
            filedialog.askopenfilename,
            self.load_image_file
        """
        typeslist = [("IMG file", ".img"), ("JPG file", ".jpg"), 
                     ("PNG file", ".png"), ("PDF file", ".pdf"), 
                     ("GIF file", ".gif"), ("BITMAP", ".bmp"),
                     ("JPEG file", ".jpeg"), ("*", ".*")]
        Sfile = filedialog.askopenfilename(title = "SÃ©lectionnez un fichier", 
                                           filetypes = typeslist)
        if Sfile != "":
            self.load_image_file(Sfile, app)
        
class HelpWindow():
    def __init__(self, app, directory = "./options"):
        assert isinstance(app, Application) 
        self.dir = directory
        self.word_list = [x[:x.index(".help")] for x in os.listdir(self.dir) 
                          if x.endswith(".help")]
        self.application = app
        self.helpWindow = tk.Tk()
        self.helpWindow.title("help")
        self.helpWindow.geometry("686x480")
        self.helpWindow.config(bg = "#111111")
        self.helpFrame = tk.Frame(self.helpWindow, 
                                   height = 30, 
                                   width = 86)
        self.helpFrame.pack()
        self.accepted_helpText = tk.Text(self.helpFrame, 
                                          height = 4, 
                                          width = 84)
        self.accepted_helpText.pack(side = TOP)
        self.helpText = tk.Text(self.helpFrame, 
                                 height = 28, 
                                 width = 84, 
                                 state = DISABLED)
        self.boxFrame = tk.Frame(self.helpFrame, 
                                     height = 5, 
                                     width = 84)
        self.boxFrame.pack(side = TOP)
        self.wordBox = ttk.Combobox(self.boxFrame, 
                                  values = self.word_list,
                                  state = "readonly")
        self.wordBox.bind("<<ComboboxSelected>>", self.words_help)
        self.wordBox.pack(side = TOP)
        self.helpText.pack(side = TOP)
        self.accepted_helpText.insert("end", "The help about technical terms"+
                    " about the segmentation of an image based on a compact\n"+
                    "representation of the color histogram.\n")
        self.accepted_helpText["state"] = DISABLED
        self.helpWindow.protocol("WM_DELETE_WINDOW", 
                                 self.on_closing_help)
    def words_help(self, event):
        word = self.wordBox.get()
        self.helpText["state"] = NORMAL
        self.helpText.delete("1.0", "end")
        with open(self.dir + "/" + word + ".help", "r") as help_file:
            self.helpText.insert("end", help_file.read())
        self.helpText["state"] = DISABLED
    def on_closing_help(self):
        self.application.helpWindow = None
        self.application.helpOpen = False
        self.helpWindow.destroy()
        del(self)
    def lift(self):
        self.helpWindow.lift()
        self.helpWindow.focus_force()
        self.helpWindow.grab_set()
        self.helpWindow.grab_release()
        
class Application:
    
    def on_closing(self):
       """
       ========================================================================
       This is the closing protocol, it is activated on the closing of the 
       main window.
       Its purpose is to delete every temporary file that has been created 
       during the session and then to destroy the window.
       If a help window is open this protocol will close it before destroying 
       the window.
       ========================================================================
       Calls:
           HelpWindow.on_closing_help
           os.remove,
           os.rmdir,
           TkinterDnD.Tk.destroy,
           TkinterDnD.Tk.quit
       """
       if self.helpOpen:
           self.helpWindow.on_closing_help()
       for file in os.scandir(self.tmpPath):
           os.remove(file)
       os.rmdir(self.tmpPath)
       self.window.destroy()
       self.window.quit()
                
    def show_help(self):
        if(self.helpOpen):
            self.helpWindow.lift()
        else:
            self.helpOpen = True
            self.helpWindow = HelpWindow(self)
            self.helpWindow.lift()
    
    def save(self):
        directory = filedialog.askdirectory(title = "Save result to:",
                                            initialdir = "./save"+
                                            datetime.now().strftime(
                                                "%d-%m-%y-%H-%M-%S"))
        if directory == "" or directory == None:
            return()
        if not os.path.exists(directory):
            os.mkdir(directory)
        assert os.path.isdir(directory), {"The path for the saver"+
                                          " must lead to a directory."}
        saver = Saver(directory)
        for img in self.results:
            saver.save(img)
        return()
    
    def compute(self):
        self.results = self.cli.compute(returning = True)
    
    def parse_background_color(self) -> str:
        """
        =======================================================================
        This method is the parser for default value of the attribute database.
        It is called when the --database or -db argument is not used.
        It finds the default value in the self.default file.
        =======================================================================
        Returns:
            Integer stated in the self.default file.
            255 if the default value is None 
            (255 is the default value at initialisation of the Application)
        """
        for s in self.cli.default:
            if match(r"background_color", s):

                if s.endswith("None"):
                    return("#000000")
                else:
                    return(str(s[s.index("=")+1:].strip()))
    
    def show_hist1(self):
        if self.histCheckValue.get() == 1 and self.cli._args.image != None:
            if self.figure == BLANK_FIG:
                self.figure = plt.figure(dpi = 300)
            plt.clf()
            imgpath = self.cli._args.image.getpath()
            filename = self.cli._args.image.getpath()[imgpath.rindex("/")+1:
                                imgpath.index(".")]
            if os.path.exists(self.tmpPath +f"/Hist{filename}.png"):
                plt.close()
                with open(self.tmpPath+f"/Hist{filename}.hist", "rb") as file:
                    self.histo = pickle.load(file)
            else:
                self.histo = Histogram(self.cli._args.image)
                
                if isinstance(self.histo, ColorHistogram):
                    plt.hist(self.histo.get_red())
                    plt.hist(self.histo.get_green())
                    plt.hist(self.histo.get_blue())
                elif isinstance(self.histo, GreyHistogram):
                    plt.hist(self.histo.get_grey())
                    
                plt.show()
                plt.draw()    
                plt.rcParams["figure.figsize"] = (5,4.5)
            
                with open(self.tmpPath+f"/Hist{filename}.hist", "wb") as file:
                    pickle.dump(self.histo, file, 
                                protocol=pickle.HIGHEST_PROTOCOL)
                plt.savefig(self.tmpPath +f"/Hist{filename}.png", format="PNG")
        else:
#                filename = self.cli._args.image.getpath()[:
#                                    self.cli._args.image.getpath().index(".")]
#                if os.path.exists(self.tmpPath + f"/Hist{filename}.png"):
#                    os.remove(self.tmpPath + "/Hist{filename}.png")
                plt.close()
    
    def try_database(self):
        tmp = self.cli._args.database
        self.dbErrorFrame = tk.Frame(self.databaseFrame)
        self.databaseErrorLabel = tk.Label(self.dbErrorFrame)
        try:
            self.cli._args.database = Database(self.databaseEntry.get())
            self.databaseErrorLabel.master.destroy()
        except AssertionError as e:
            self.databaseErrorLabel.configure(text = str(e))
            self.databaseErrorLabel.pack(side = BOTTOM)
            self.dbErrorFrame.pack(side = BOTTOM)
            self.cli._args.database = tmp
    
    def __init__(self, options = "./options/CLI.init"):
                
        self.tmpPath = "temp"
        while os.path.exists(self.tmpPath):
            self.tmpPath += "p"
        os.mkdir(self.tmpPath)
        
        self.cli = CLI(defaultDir=options[:options.rindex("/")], 
            defaultFile = options[options.rindex("/")+1:])
        
        self.window = tkd.TkinterDnD.Tk()
        self.window.title('Application')
        self.window.geometry('750x800')
        self.window.config(bg = self.parse_background_color())
        
        self.ws = tk.Frame(self.window)
        self.ws.pack(side = TOP)
        
        self.optionFrame = tk.Frame(self.ws, height = 10, width = 40)
        self.optionFrame.pack(side = TOP)

        self.frame = tk.Frame(self.ws, height = 60, width = 82)
        self.frame.pack(side = LEFT)
        
        self.resultFrame = tk.Frame(self.ws)
        self.resultFrame.pack(side = RIGHT)
        
        self.frameDnD = tk.Frame(self.frame, height = 23, width = 41)
        self.frameDnD.pack(side = TOP)
        
        self.computeFrame = tk.Frame(self.frame)
        self.computeFrame.pack(side = BOTTOM)
        
        self.window.lift()
        self.window.focus_force()
        self.window.grab_set()
        self.window.grab_release()
        
        self.image = self.cli._args.image
        self.figure = Figure()
        self.helpOpen = False
        
        self.histCheckValue = tk.IntVar()
        self.histCheck = tk.Checkbutton(self.frameDnD, 
                                     disabledforeground = "grey", 
                                     text = "see the histogram", 
                                     variable = self.histCheckValue, 
                                     command = self.show_hist1, 
                                     state = DISABLED,
                                     onvalue = 1)
        self.histCheck.grid(row = 7, column = 0)
        
        self.canvas = CanvasDnD(self.frameDnD, height=250, width=500)
        self.canvas.grid(row = 1, column = 0, rowspan = 3, columnspan = 6)
        self.canvas.drop_target_register(tkd.DND_FILES)
        self.canvas.dnd_bind('<<Drop>>', lambda x:
                                         {self.canvas.load_image_drop(x,self) 
                                          or self.histCheck.configure(
                                             state = "normal")})
        
        self.databaseFrame = tk.Frame(self.computeFrame)
        self.databaseFrame.pack(side = TOP)
        self.databaseName = tk.StringVar()
        self.databaseEntry = tk.Entry(self.databaseFrame,
                                      textvariable = self.databaseName)
        self.databaseLabel = tk.Label(self.databaseFrame, text = "Database: ")
        self.databaseLabel.pack(side = LEFT)
        self.databaseEntry.pack(side = TOP)
        
        self.depthFrame = tk.Frame(self.computeFrame)
        self.depthFrame.pack(side = TOP)
        self.depthValue = tk.IntVar()
        self.depthEntry = tk.Entry(self.depthFrame, 
                                   textvariable = self.depthValue,
                                   text = self.depthValue)
        self.depthValue.set(5)
        self.depthLabel = tk.Label(self.depthFrame, text = "Depth: ")
        self.depthLabel.pack(side = LEFT)
        self.depthEntry.pack(side = TOP)
        
        if self.image != None:
            self.canvas.load_image_file(self.image.getpath(), self)
        else:
            self.canvas.load_image_file(DEFAULT_DND_CANVAS_IMAGE, self)
        
        self.openButton = tk.Button(self.frameDnD, 
                                activebackground = "blue", 
                                bg = "white", 
                                text = "open", 
                                command = lambda :
                                        self.canvas.load_image_selection(self))
        self.openButton.grid(row = 7, column = 0, columnspan = 6)
        
        self.helpOption = tk.Button(self.optionFrame, 
                                activebackground = "red", 
                                bg = "white", 
                                text = "Help", 
                                command = self.show_help)
        self.helpOption.pack(side = LEFT)
        
        self.saveOption = tk.Button(self.optionFrame, 
                                activebackground = "blue", 
                                bg = "white", 
                                text = "save", 
                                command = self.save)
        self.saveOption.pack(side = LEFT)
        
        self.computeButton = tk.Button(self.computeFrame, 
                                   height = 8, 
                                   width = 58, 
                                   text = "COMPUTE", 
                                   activebackground = "yellow", 
                                   bg = "blue", 
                                   command = self.compute)
        self.computeButton.pack(side = TOP)
        
        self.resultLabel = tk.Label(self.resultFrame, text = "Restults: ")
        self.resultLabel.pack(side = TOP)
        
        self.resultCanvas = tk.Canvas(self.resultFrame)
        self.resultCanvas.pack(side = BOTTOM)
        
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        self.window.title("Segmentation tool")
        
        self.window.mainloop()

if __name__ == "__main__":
    a = Application()
    del(a)