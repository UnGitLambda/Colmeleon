#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import csv
import pickle
from Histogram import Histogram
from Image import Image, check_extension
import shutil


class Database:
    """
    ===========================================================================
    Class taking care of the exploitaation of the database : it creates the
    histograms of all images that are to be taken into account and offers
    methods to retrieve both histograms and images.
    ===========================================================================
    Important public methods :
        histograms : retrieves the histograms of the images that were computed
        images : retrieves the images
        add : allows user to add an image and its histograms to the base
    """

    def __init__(self,directory):
        """
        The path to the directory is given as a String.
        It must be either absolute or relative to the current directory.
        """
        assert type(directory) is str, {"Database: the path to the directory"+
                                        " must be given as a String, it can"+
                                        f" not be {type(directory)}"}.pop()
        assert os.path.exists(directory), {"Database: The path given leads"+
                                           " nowhere, please fix this issue"+
                                           " before trying again."}.pop()
        assert os.path.isdir(directory), {"Database: The path given does not"+
                                          " lead to a directory, please fix"+
                                          " this issue before trying"+
                                          " again."}.pop()
        self._database = directory

    def get_dir(self):
        return(self._database)

    def color_axes(histo, rg_bins_number = 16, by_bins_number = 16,
                    wb_bins_number = 8) ->np.ndarray:
    """
    ===========================================================================
    This function will create the color axes used in incremental intersection
    ===========================================================================
    Argument :
        histo : The concerned histogram
        rg_bins : The number of bins for the rg color axe (default : 16)
        by_bins : The number of bins for the by color axe (default : 16)
        wb_bins : The number of bins for the wb color axe (default :  8)
    Return :
        the keys of rg,by and wb values concatenated into a single vector
        (the key of a value is the fraction of the total number of pixels)
    Raises :
        Exception error if the histogram in input doesn't possess a
            ColorHistogram or a GreyHistogram
    """
        assert type(histo) is Histogram

        if isinstance(histo.histograms, ColorHistogram) :
            r = histo.image_array[:,:,0]
            g = histo.image_array[:,:,1]
            b = histo.image_array[:,:,2]
        elif isinstance(histo.histograms, GreyHistogram) :
            r = histo.histograms.grey[:,:]
            g,b = r,r
        else :
            raise Exception("The histogram in argument doesn't have a "+
                        "ColorHistogram nor a GreyHistogram, so it isn't "+
                        "possible to create the associated bins histogram")

        rg = r - g
        by = 2 * b - r -g
        wb = r + g + b
        rg_bins = plt.hist(rg.flatten(), bins = rg_bins_number, range = [0,255])
        by_bins = plt.hist(by.flatten(), bins = by_bins_number, range = [0,255])
        wb_bins = plt.hist(wb.flatten(), bins = wb_bins_number, range = [0,255])

        #applying key that is the fraction of the total number of pixels
        total_pixel = len(histo.image_array[0]) * len(histo.image_array)
        return np.concatenate([rg_bins[0],by_bins[0],wb_bins[0]])/total_pixel

    def _calculate_histogram(self,file)->(string,string):
        """
        =======================================================================
        Instantiates then saves the color histogram and the bins histogram of
        one given file in the database
        =======================================================================
        Argument :
            file : the path to the file, either absolute or relative to the
            current directory.
        Returns :
            a tuple containing : the path to the histogram, the path to the bins
            histogram. Both paths are either absolute or relative to the current
            directory, depends on the path to the database being absolute or not.
        """
        #calculate the histogram
        histo = Histogram(Image(file))
        #save the histogram in the database
        repertory = self._database+os.sep+"histograms"
        name = file[file.rindex('/'):len(file)-4]+'_hist'
        with open(repertory+os.sep+name,'wb+') as histo_file:
            pickle.dump(histo,histo_file,protocol=pickle.HIGHEST_PROTOCOL)

        #calculate the bins histogram
        histo_bin = color_axes(histo)
        #save the bins histogram in the database
        repertory_bin = self._database+os.sep+"bins_histograms"
        with open(repertory_bin+os.sep+name+'bin','wb+') as histo_bin_file:
            pickle.dump(histo_bin,histo_bin_file,protocol=pickle.HIGHEST_PROTOCOL)

        #returns paths to both histogram files
        return (repertory+os.sep+name,repertory_bin+os.sep+name+'bin')

    def explore(self, depth=1)->list:
        """
        =======================================================================
        Explore the database down to depth. By default, explore only the first
        directory.
        =======================================================================
        Arguments :
            depth : the depth to which it must be explored. If greater than the
            real depth, all the database will be explored. Should not be
            greater than 5 for efficiency reasons.
        Returns :
            List of the paths of all files in the database, in form of strings.
        """
        res = []
        #supress the last separator to not falsely count it
        directory = self._database.rstrip(os.path.sep)
        assert os.path.isdir(directory)
        #calculate the depth of first directory to track the depth of the
        #search
        num_sep = directory.count(os.path.sep)
        #start of exploration
        for root, dirs, files in os.walk(directory):
            #we're only interested in the files
            for file in files :
                res.append(str(os.path.join(root,
                                            file)).replace(os.path.sep,'/'))
            num_sep_this = root.count(os.path.sep)
            #if it's already max depth
            if num_sep + depth <= num_sep_this:
                #do not explore deeper
                del dirs[:]
        return res


    def _calculate_histograms(self, max_depth=1):
        """
        =======================================================================
        Computes all images in the database to create their histograms,
        then stocks them in a new directory named "histograms".
        Note : all Histogram objects are pickled before being saved.
        =======================================================================
        Arguments :
            max_depth : the depth of the database. Confere to explore for
            details.
        """
        #TODO optimize
        depth = max_depth
        files = self.explore()

        #all histograms are saved in a dedicated repertory
        repertory = self._database+os.sep+"histograms"
        if not os.path.exists(repertory):
            os.makedirs(repertory)

        #if histograms.csv exists in the database
        if 'histograms.csv' in files :
            #first find all images that already had their histogram created
            with open(self._database+os.sep+'histograms.csv','r') as csv_file :
                filereader = csv.reader(csv_file)
                images_ready = []
                for item in list(filereader) :
                    if len(item)>0 :
                        images_ready.append(item[0])
            #then add the new images
            with open(self._database+os.sep+'histograms.csv','a') as csv_file :
                filewriter = csv.writer(csv_file)
                #we'll consider the images that do not already have their
                #histogram
                for file in files :
                    if check_extension(file) and (os.path.relpath(file) not
                                                  in images_ready) :
                        histo = self._calculate_histogram(file)
                        #save the path to image and the histogram in csv
                        filewriter.writerow([os.path.relpath(file),
                                             histo[0],histo[1]])

        #if there is no histograms.csv file already existing in the directory
        else:
            with open(self._database+os.sep+'histograms.csv','w') as csv_file :
                filewriter = csv.writer(csv_file,delimiter=',')
                for file in files:
                    #we only consider valid image formats
                    if check_extension(file) :
                        histo = self._calculate_histogram(file)
                        #save the path to image and the histogram in csv
                        filewriter.writerow([os.path.relpath(file),
                                             histo[0],histo[1])

    def histograms(self):
        """
        =======================================================================
        Generator that unpickle all the histograms and generates one at a time
        with the path to its image.
        =======================================================================
        Yields :
            a tuple (pointer to image,histogram) for each image in the base.
        """
        files = os.listdir(self._database)
        #res = []
        #find the histograms.csv file
        if 'histograms.csv' in files :
            with open(self._database+os.sep+'histograms.csv','r') as csv_file :
                #read the file to find the histograms
                filereader = csv.reader(csv_file)
                for item in filereader :
                    #to skip blank lines
                    if len(item)>0:
                        #unpickle the histogram
                        histo = None
                        with open(item[1],'rb') as pickled_histo :
                            histo = pickle.load(pickled_histo)
                        #res.append((item[0],histo))
                        yield (item[0],histo)
        else :
            print("Caution: the histograms were never calculated"+
                  " for this database.")

        #return res

    def bin_histograms(self):
        """
        =======================================================================
        Generator that unpickle all the bins_histograms and generates one at a
        time with the path to its image.
        =======================================================================
        Yields :
            a tuple (pointer to image,histogram) for each image in the base.
        """
        files = os.listdir(self._database)
        #find the histograms.csv file
        if 'histograms.csv' in files :
            with open(self._database+os.sep+'histograms.csv','r') as csv_file :
                #read the file to find the histograms
                filereader = csv.reader(csv_file)
                for item in filereader :
                    #to skip blank lines
                    if len(item)>0:
                        #unpickle the histogram
                        histo = None
                        with open(item[2],'rb') as pickled_histo :
                            histo = pickle.load(pickled_histo)
                        #res.append((item[0],histo))
                        yield (item[0],histo)
        else :
            print("Caution: the histograms were never calculated"+
                  " for this database.")

    def images(self)->list:
        """
        Returns:
            a list containing pointers to all images in the database
        """
        files = os.listdir(self._database)
        res = []
        for file in files:
            if check_extension(file):
                res.append(file)
        return res



    def add(self,img,histo):
        """
        =======================================================================
        Allows user to add an image file and its Histogram object to the base.
        =======================================================================
        Returns :
            true if couple was correctly added to the database.
        Arguments :
            img : the path to the image file to be added
            histo : the Histogram object of the image
        """
        files = os.listdir(self._database)
        #add image
        name_img = os.path.basename(str(img))
        new_path = os.path.relpath(self._database+os.sep+name_img)
        shutil.copy(str(img),new_path)
        #save the histogram in the database
        name_histo = new_path[:-4]+'_hist'
        with open(name_histo,'wb+') as histo_file :
            pickle.dump(histo,histo_file,protocol=pickle.HIGHEST_PROTOCOL)
        #check if database isn't empty
        if 'histograms.csv' in files :
            with open(self._database+os.sep+'histograms.csv','a') as csv_file :
                print(os.path.relpath(name_histo))
                #we add the couple of adresses to the csv file
                filewriter = csv.writer(csv_file)
                filewriter.writerow([os.path.relpath(name_img),
                                     os.path.relpath(name_histo)])
        #this image is the first in the base
        else :
            print("This is the first image added to that base")
            with open(self._database+os.sep+'histograms.csv','w+') as csv_file :
                #we add the couple of adresses to the csv file
                filewriter = csv.writer(csv_file)
                filewriter.writerow([os.path.relpath(img),
                                     os.path.relpath(name_histo)])

    def __str__(self):
        return(self._database)