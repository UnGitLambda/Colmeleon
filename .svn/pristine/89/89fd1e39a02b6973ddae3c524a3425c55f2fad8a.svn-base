# -*- coding: utf-8 -*-
"""
Created in 07/2021
@author: Eyal Cohen
"""


try:
    import sys
except Exception as e:
    print("\nError message :" + str(e) + "\n")
    print("It seems that the module 'sys' is not installed on your computer (or not accessible via PATH), please install it for PAFtoAF and PAFtoAFGUI to work properly.\n")
    print("You should be able to install it using the command :\npython -m pip install sys")
    exit()

try:
    import ctypes
except Exception as e:
    print("\nError message :" + str(e) + "\n")
    print("It seems that the module 'ctypes' is not installed on your computer (or not accessible via PATH), please install it for PAFtoAFcheckup to work properly.\n")
    print("You should be able to install it using the command :\npython -m pip install ctypes")
    sys.exit()

import ctypes  # An included library with Python install.
def Mbox(title, text, style):
    return ctypes.windll.user32.MessageBoxW(0, text, title, style)

#    from matplotlib.figure import Figure
#    import matplotlib.pyplot as plt
#    import matplotlib
#    matplotlib.use("TkAgg")
import os
import tkinter as tk
from tkinter import filedialog
from tkinter import DISABLED, NORMAL
from tkinter import BOTTOM, TOP, LEFT, RIGHT
from tkinter import ttk
from PIL import ImageTk, Image
#    import networkx as nx
#    from networkx import NetworkXException
import tkinterdnd2 as tkd
#    import platform
from datetime import (date, datetime)

#    system = platform.system()
#    if system not in ["Windows", "Linux", "Darwin"]:
#        root = tk.Tk()
#        root.withdraw()
#        msg = tk.messagebox.showinfo("Error", "It looks like you system is not supported.\nSupported systems : Windows, Linux, Darwin(MacOS)\nYour system : {}".format(system))
#        while msg != "ok":
#            continue
#        sys.exit()

if sys.version_info < (3,0):
    print("This program runs under python 3 or more. To use it please get you version of python up to date.")
    Mbox("Errors", "This program runs under python 3 or more. To use it please get you version of python up to date.")

class Application:
    def __init__(self):
        if os.path.exists("temp"):
            if not (os.path.isdir("temp")):
                os.remove("temp")
            else:
                for file in os.scandir("temp"):
                    os.remove(file)
                os.rmdir("temp")
        os.mkdir("temp")
        
        window = tkd.TkinterDnD.Tk()
        window.title('Application')
        window.geometry('750x800')
        window.config(bg='#554356')
        
        ws = tk.Frame(window)
        ws.pack(side = TOP)
        
        frame = tk.Frame(ws, height = 60, width = 82)
        frame.pack()
        
        optionframe = tk.Frame(frame, height = 10, width = 40)
        optionframe.pack(side = TOP)
        
        frameDnD = tk.Frame(frame, height = 23, width = 41)
        frameDnD.pack(side = LEFT)
        
        compute_frame = tk.Frame(ws)
        compute_frame.pack(side = BOTTOM)
        
        def on_closing():
           """
           This is the closing protocol, it is activated on the closing of the main window.
           Its purpose is to delete every temporary file that has been created during the session and then to destroy the window.
           """
           global graph_value
           for file in os.scandir("temp"):
               os.remove(file)
           os.rmdir("temp")
           window.destroy()
           window.quit()
        
        
        #TODO resize dynamically the canvas size to perfectly fit the image
        #TODO resize the window and add a scrollbar to fit the canvas
        
        def load_image(event):
            self.image = ImageTk.PhotoImage(Image.open(str(event.data).replace("{", "").replace("}", "")));
            canvas.config(height = self.image.height(), width = self.image.width())
            canvas.create_image(self.image.width(), self.image.height(), image = self.image, anchor = tk.SE)
        
        def load_image_file(Sfile):
            self.image = ImageTk.PhotoImage(Image.open(Sfile));
            canvas.config(height = self.image.height(), width = self.image.width())
            canvas.create_image(self.image.width(), self.image.height(), image = self.image, anchor = tk.SE)
        
        def load_image_selection():
            """
            This method is the one used by the button open (for the files) on the GUI.
            It opens a window allowing the user to browse its file and then reads and load the selected file.
            """
            typeslist = [("IMG file", ".img"), ("JPG file", ".jpg"), ("*", ".*")]
            Sfile = filedialog.askopenfilename(title = "SÃ©lectionnez un fichier ..." , filetypes = typeslist)
            load_image_file(Sfile)
            
        def reload_image():
            return()
        
        def show_help():
            def show_segmentation():
                help_text["state"] = NORMAL
                help_text.delete("1.0", "end")
                help_text.insert("end", "\nThe segmentation consists in separating differents regions of the\nimage, based on characteristics.\n")
                segButton["bg"] = "red"
                segButton["state"] = DISABLED
                retrButton["bg"] = "white"
                retrButton["state"] = NORMAL
                help_text["state"] = DISABLED
            def show_retrieval():
                help_text["state"] = NORMAL
                help_text.delete("1.0", "end")
                help_text.insert("end", "\nThe retrieval consists in getting items from\nthe database.\n")
                retrButton["bg"] = "red"
                retrButton["state"] = DISABLED
                segButton["bg"] = "white"
                segButton["state"] = NORMAL
                help_text["state"] = DISABLED
            help_window = tk.Tk()
            help_window.title("help")
            help_window.geometry("686x480")
            help_window.config(bg = "#dddddd")
            help_frame = tk.Frame(help_window, height = 30, width = 86)
            help_frame.pack()
            accepted_help_text = tk.Text(help_frame, height = 4, width = 84)
            accepted_help_text.pack(side = TOP)
            help_text = tk.Text(help_frame, height = 28, width = 84, state = DISABLED)
            buttonsframe = tk.Frame(help_frame, height = 5, width = 84)
            buttonsframe.pack(side = TOP)
            segButton = tk.Button(buttonsframe, text = "Segmentation", bg = "white", activebackground = "red", command = show_segmentation)
            retrButton = tk.Button(buttonsframe, text = "Retrieval", bg = "white", activebackground = "red", command = show_retrieval)
            segButton.pack(side = LEFT)
            retrButton.pack(side = LEFT)
            help_text.pack(side = TOP)
            accepted_help_text.insert("end", "The help about technical terms about :\nSegmentation of an image based on a compact representation of the color histogram.\n")
        
        def save():
            return()
        
        def compute():
            return()
        
        canvas = tk.Canvas(frameDnD, height=250, width=500)
        canvas.grid(row = 1, column = 0, rowspan = 3, columnspan = 6)
        canvas.drop_target_register(tkd.DND_FILES)
        canvas.dnd_bind('<<Drop>>', load_image)
    #    textarea.insert("end", "\n\nPlease drag a file here.\n\nOr click the 'open' button under this\nbox to select a file.\n\nAccepted format is jpg.")
        
    #    sbv = tk.Scrollbar(frameDnD, orient=tk.VERTICAL)
    #    sbv.grid(row = 1, column = 7, rowspan = 6, columnspan = 6, sticky = tk.NS)
        
    #    textarea.configure(yscrollcommand=sbv.set)
    #    sbv.config(command=textarea.yview)
        
        open_button = tk.Button(frameDnD, activebackground = "blue", bg = "white", text = "open", command = load_image_selection)
        open_button.grid(row = 7, column = 0, columnspan = 6)
        
        reload_button= tk.Button(frameDnD, activebackground = "red", bg = "white", text = "reload", command = reload_image, width = 46)
        reload_button.grid(row = 0, column = 0, columnspan = 6)
        
    #    graph_check_value = tk.IntVar()
    #    graph_check = tk.Checkbutton(frameDnD, disabledforeground = "yellow", text = "generate the graph", variable = graph_check_value, command = show_graph, onvalue = 1, state = DISABLED)
    #    graph_check.grid(row = 7, column = 0)
        
        help_option = tk.Button(optionframe, activebackground = "red", bg = "white", text = "Help", command = show_help)
        help_option.pack(side = LEFT)
        
        save_option = tk.Button(optionframe, activebackground = "blue", bg = "white", text = "save", command = save)
        save_option.pack(side = LEFT)
        
    #    semantic_value = tk.StringVar()
    #    semantic_box = ttk.Combobox(taskframe, values = ["CO","PR","ST","SST","STG","GR","ID"], state = DISABLED, textvariable = semantic_value)
    #    semantic_box.bind("<<ComboboxSelected>>", semantic_selection)
    #    semantic_box.grid(row = 1, column = 2)
        
    #    sbvR = tk.Scrollbar(frameReduction, orient=tk.VERTICAL)
    #    sbvR.grid(row = 1, column = 7, rowspan = 6, columnspan = 6, sticky = tk.NS)
        
    #    textareaReduc.configure(yscrollcommand = sbvR.set)
    #    sbvR.config(command = textareaReduc.yview)
        
        compute_button = tk.Button(compute_frame, height = 8, width = 68, text = "COMPUTE", activebackground = "yellow", bg = "blue", command = compute)
        compute_button.pack(side = TOP)
        
        window.protocol("WM_DELETE_WINDOW", on_closing)
        
        window.mainloop()
            

if __name__ == "__main__":
    a = Application()