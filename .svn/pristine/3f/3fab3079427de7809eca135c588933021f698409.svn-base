# -*- coding: utf-8 -*-
"""
@author: Eyal Cohen
"""

try:
    import sys
except Exception as e:
    print("\nError message :" + str(e) + "\n")
    print("It seems that the module 'sys' is not installed on your computer (or not accessible via PATH), please install it for PAFtoAF and PAFtoAFGUI to work properly.\n")
    print("You should be able to install it using the command :\npython -m pip install sys")
    exit()

try:
    import ctypes
except Exception as e:
    print("\nError message :" + str(e) + "\n")
    print("It seems that the module 'ctypes' is not installed on your computer (or not accessible via PATH), please install it for PAFtoAFcheckup to work properly.\n")
    print("You should be able to install it using the command :\npython -m pip install ctypes")
    sys.exit()

def Mbox(title, text, style):
    return ctypes.windll.user32.MessageBoxW(0, text, title, style)

from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use("TkAgg")
import os
import numpy as np
import tkinter as tk
from tkinter import filedialog
from tkinter import DISABLED, NORMAL
from tkinter import BOTTOM, TOP, LEFT
from PIL import ImageTk, Image
import tkinterdnd2 as tkd
import HelpWindow as hp

#import platform

#    system = platform.system()
#    if system not in ["Windows", "Linux", "Darwin"]:
#        root = tk.Tk()
#        root.withdraw()
#        msg = tk.messagebox.showinfo("Error", "It looks like you system is not supported.\nSupported systems : Windows, Linux, Darwin(MacOS)\nYour system : {}".format(system))
#        while msg != "ok":
#            continue
#        sys.exit()

if sys.version_info < (3,0):
    print("This program runs under python 3 or more. To use it please get you version of python up to date.")
    Mbox("Errors", "This program runs under python 3 or more. To use it please get you version of python up to date.")

class Application:
    def __init__(self):
        self.tmpPath = "temp"
        while os.path.exists(self.tmpPath):
            self.tmpPath += "temp"
        os.mkdir(self.tmpPath)
        
        window = tkd.TkinterDnD.Tk()
        window.title('Application')
        window.geometry('750x800')
        window.config(bg='#554356')
        
        ws = tk.Frame(window)
        ws.pack(side = TOP)
        
        frame = tk.Frame(ws, height = 60, width = 82)
        frame.pack()
        
        optionFrame = tk.Frame(frame, height = 10, width = 40)
        optionFrame.pack(side = TOP)
        
        frameDnD = tk.Frame(frame, height = 23, width = 41)
        frameDnD.pack(side = LEFT)
        
        computeFrame = tk.Frame(ws)
        computeFrame.pack(side = BOTTOM)
        
        window.lift()
        window.focus_force()
        window.grab_set()
        window.grab_release()
        
        
        self.image = None
        self.figure = Figure()
        self.helpOpen = False
        
        def on_closing():
           """
           This is the closing protocol, it is activated on the closing of the main window.
           Its purpose is to delete every temporary file that has been created during the session and then to destroy the window.
           """
           if self.helpOpen:
               self.helpWindow.on_closing_help()
           for file in os.scandir(self.tmpPath):
               os.remove(file)
           os.rmdir(self.tmpPath)
           window.destroy()
           window.quit()
        
        
        #TODO resize dynamically the canvas size to perfectly fit the image
        #TODO resize the window and add a scrollbar to fit the canvas
        
        def load_image(event):
            self.image = Image.open(str(event.data).replace("{", "").replace("}", ""));
            scale = min(512/self.image.width,512/self.image.height)
            img = self.image.resize((int(scale*self.image.width), int(scale*self.image.height)))
            self.tkImg = ImageTk.PhotoImage(img)
            canvas.config(height = self.tkImg.height(), width = self.tkImg.width())
            canvas.create_image(self.tkImg.width(), self.tkImg.height(), image = self.tkImg, anchor = tk.SE)
            hist1_check["state"] = NORMAL
            show_hist1()
        
        def load_image_file(Sfile):
            self.image = Image.open(Sfile);
            scale = min(512/self.image.width,512/self.image.height)
            img = self.image.resize((int(scale*self.image.width), int(scale*self.image.height)))
            self.tkImg = ImageTk.PhotoImage(img)
            canvas.config(height = self.tkImg.height(), width = self.tkImg.width())
            canvas.create_image(self.tkImg.width(), self.tkImg.height(), image = self.tkImg, anchor = tk.SE)
            hist1_check["state"] = NORMAL
            show_hist1()
        
        def load_image_selection():
            """
            This method is the one used by the button open (for the files) on the GUI.
            It opens a window allowing the user to browse its file and then reads and load the selected file.
            """
            typeslist = [("IMG file", ".img"), ("JPG file", ".jpg"), ("PNG file", ".png"), ("PDF file", ".pdf"), ("*", ".*")]
            Sfile = filedialog.askopenfilename(title = "SÃ©lectionnez un fichier ..." , filetypes = typeslist)
            load_image_file(Sfile)
            
        def show_help():
            if(self.helpOpen):
                self.helpWindow.lift()
            else:
                self.helpOpen = True
                self.helpWindow = hp.HelpWindow(self)
                self.helpWindow.lift()
        
        def save():
            return()
        
        def compute():
            return()
        
        def show_hist1():
            if hist1_check_value.get() == 1:
                if self.figure == Figure():
                    self.figure = plt.figure(dpi = 100)
                plt.clf()
                
                img_array = 255-np.asarray(self.image)
                plt.hist(img_array[:,:,0].flatten()*255,range=[0,255], color = "red", alpha = 0.5, bins = 256)
                plt.hist(img_array[:,:,1].flatten()*255,range=[0,255], color = "green", alpha = 0.5, bins = 256)
                plt.hist(img_array[:,:,2].flatten()*255,range=[0,255], color = "blue", alpha = 0.5, bins = 256)
                plt.show()
                plt.draw()    
                
                plt.rcParams["figure.figsize"] = (10,9)
                
                plt.savefig(self.tmpPath + "/Hist1.png", format="PNG")
            else:
                if os.path.exists(self.tmpPath + "/Hist1.png"):
                    os.remove(self.tmpPath + "/Hist1.png")
                plt.close()
        
        canvas = tk.Canvas(frameDnD, height=250, width=500)
        canvas.grid(row = 1, column = 0, rowspan = 3, columnspan = 6)
        canvas.drop_target_register(tkd.DND_FILES)
        canvas.dnd_bind('<<Drop>>', load_image)
    #    textarea.insert("end", "\n\nPlease drag a file here.\n\nOr click the 'open' button under this\nbox to select a file.\n\nAccepted format is jpg.")
        
    #    sbv = tk.Scrollbar(frameDnD, orient=tk.VERTICAL)
    #    sbv.grid(row = 1, column = 7, rowspan = 6, columnspan = 6, sticky = tk.NS)
        
    #    textarea.configure(yscrollcommand=sbv.set)
    #    sbv.config(command=textarea.yview)
        
        open_button = tk.Button(frameDnD, activebackground = "blue", bg = "white", text = "open", command = load_image_selection)
        open_button.grid(row = 7, column = 0, columnspan = 6)
        
        
        hist1_check_value = tk.IntVar()
        hist1_check = tk.Checkbutton(frameDnD, disabledforeground = "yellow", text = "generate the graph", variable = hist1_check_value, command = show_hist1, onvalue = 1, state = DISABLED)
        hist1_check.grid(row = 7, column = 0)
        
        help_option = tk.Button(optionFrame, activebackground = "red", bg = "white", text = "Help", command = show_help)
        help_option.pack(side = LEFT)
        
        save_option = tk.Button(optionFrame, activebackground = "blue", bg = "white", text = "save", command = save)
        save_option.pack(side = LEFT)
        
    #    semantic_value = tk.StringVar()
    #    semantic_box = ttk.Combobox(taskframe, values = ["CO","PR","ST","SST","STG","GR","ID"], state = DISABLED, textvariable = semantic_value)
    #    semantic_box.bind("<<ComboboxSelected>>", semantic_selection)
    #    semantic_box.grid(row = 1, column = 2)
        
    #    sbvR = tk.Scrollbar(frameReduction, orient=tk.VERTICAL)
    #    sbvR.grid(row = 1, column = 7, rowspan = 6, columnspan = 6, sticky = tk.NS)
        
    #    textareaReduc.configure(yscrollcommand = sbvR.set)
    #    sbvR.config(command = textareaReduc.yview)
        
        compute_button = tk.Button(computeFrame, height = 8, width = 68, text = "COMPUTE", activebackground = "yellow", bg = "blue", command = compute)
        compute_button.pack(side = TOP)
        
        window.protocol("WM_DELETE_WINDOW", on_closing)
        
        window.mainloop()

if __name__ == "__main__":
    a = Application()
    del(a)