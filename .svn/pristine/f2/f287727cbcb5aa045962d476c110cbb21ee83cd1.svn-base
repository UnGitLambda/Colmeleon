#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import copy
import sys
import os
import math
from Histogram import ColorHistogram, GreyHistogram, Histogram
from Database import Database
import matplotlib.pyplot as plt
from Image import Image
import numpy as np
import pickle

def intersection(histo_image, histo_model)-> list:
    """
    ===========================================================================
    This function calculates the intersection of two histograms.
    It takes the minimum of each composants (red, green blue and grey) between 
    the model histogram and the image given. 
    ===========================================================================
    Arguments : 
        histo_image : the Histogram object of the image
        histo_model : the Histogram object of the model
    Returns: the histogram data of the intersection of the two histograms.
    
    """
    assert type(histo_image) is Histogram
    assert type(histo_model) is Histogram
    histo=[]

    histo_min = {histo_image if histo_image.bins <= histo_model.bins 
                 else histo_model}.pop()
    histo_max = {histo_image if histo_image.bins >= histo_model.bins 
                 else histo_model}.pop()

    ratio = histo_min.bins/histo_max.bins

    if(isinstance(histo_image.histograms, ColorHistogram) 
        and isinstance(histo_model.histograms, ColorHistogram)):      
        histo.append([])
        histo.append([])
        histo.append([])
        
        for j in range(histo_min.bins):
            if (j%2) == 0:
                ratio=math.ceil(ratio)
            else:
                ratio=math.floor(ratio)
            red = sum(histo_max.histograms.get_red()[ratio*j : ratio*(j+1)])
            blue = sum(histo_max.histograms.get_blue()[ratio*j : ratio*(j+1)])
            green =sum(histo_max.histograms.get_green()[ratio*j : ratio*(j+1)])
            histo[0].append(int(min(histo_min.histograms.get_red()[j], red)))
            histo[1].append(int(min(histo_min.histograms.get_blue()[j], blue)))
            histo[2].append(int(min(histo_min.histograms.get_green()[j],
                                    green))) 
        return histo
    if(isinstance(histo_image.histograms, GreyHistogram) 
       and isinstance(histo_model.histograms, GreyHistogram)):
        for j in range(histo_min.bins):
            if (j%2)==0:
                ratio=math.ceil(ratio)
            else: 
                ratio=math.floor(ratio)
            grey = sum(histo_max.histograms.get_grey()[ratio*j : ratio*(j+1)])
            histo.append(int(min(histo_min.histograms.get_grey()[j],grey)))

        return histo
    if(isinstance(histo_image.histograms, ColorHistogram) 
       and isinstance(histo_model.histograms, GreyHistogram)):
        his = Histogram(histo_image.image, histo_image.bins, True)
        if histo_image.bins == histo_min.bins:
            for j in range(histo_min.bins):
                if (j%2)==0:
                    ratio=math.ceil(ratio)
                else: 
                    ratio=math.floor(ratio)
                grey = histo_model.histograms.get_grey()[ratio*j:ratio*(j+1)]
                histo.append(int(min(his.histograms.get_grey()[j], grey)))
        else:
            for j in range(histo_min.bins):
                if (j%2)==0:
                    ratio=math.ceil(ratio)
                else: 
                    ratio=math.floor(ratio)
                    grey = his.histograms.get_grey()[ratio*j : ratio*(j+1)]
                histo.append(int(min(histo_min.histograms.get_grey()[j],grey)))
        return histo
   

def match_value(histo_image, histo_model, function = intersection) -> float:
    """
    ===========================================================================
    This function calculates the percentage of correspondence between 
    two histograms. 
    It uses a function that represents the algorithm used.
    ===========================================================================
    Arguments : 
        histo_image : the Histogram object of the image
        histo_model : the Histogram object of the model
        function : the algorithme used for the intersection.
                   By default,it is the intersection function 
    Return : The value of correspondence between two histograms.
    """
    assert type(histo_image) is Histogram
    assert type(histo_model) is Histogram

    histo = function(histo_image, histo_model)
    pixels = {sum(histo_model.get_red() 
                  if isinstance(histo_model, ColorHistogram) 
                  else histo_model.get_grey())}.pop()
    r=0
    b=0
    g=0
    grey=0
    if(isinstance(histo_image, ColorHistogram) 
       and isinstance(histo_model, ColorHistogram)):
        for i in histo_model.bins:
            r+=histo[0][i]
            b+=histo[1][i]
            g+=histo[2][i]
        value = min([r/pixels,b/pixels,g/pixels])
    else: 
        for i in histo_model.bins:
            grey = histo[i] + grey
        value = grey/pixels
    return value*100


def color_axes(histo, rg_bins_number = 16, by_bins_number = 16, 
                wb_bins_number = 8) ->np.array:
    """
    ===========================================================================
    This function will create the color axes used in incremental intersection
    ===========================================================================
    Argument : 
        histo : The concerned histogram
    Return :
        the keys of rg,by and wb values concatenated into a single vector
        (the key of a value is the fraction of the total number of pixels)
        by default the bins number are 
            rg_bins = 16
            by_bins = 16
            wb_bins = 8
    """
    assert type(histo) is Histogram
    print(type(histo.histograms))
    if isinstance(histo.histograms, ColorHistogram) :
        r = histo.image_array[:,:,0]
        g = histo.image_array[:,:,1]
        b = histo.image_array[:,:,2]
    elif isinstance(histo.histograms, GreyHistogram) :
        r = histo.histograms.grey[:,:]
        g,b = r,r
    else :
        raise Exception("The histogram in argument doesn't have a "+
                        "ColorHistogram nor a GreyHistogram, so it isn't "+
                        "possible to create the associated bins histogram")
    
    rg = r - g
    by = 2 * b - r -g
    wb = r + g + b
    rg_bins = plt.hist(rg.flatten(), bins = rg_bins_number)
    by_bins = plt.hist(by.flatten(), bins = by_bins_number)
    wb_bins = plt.hist(wb.flatten(), bins = wb_bins_number)

    #directly applying key which is the fraction of the total number of pixels
    total_pixel = len(histo.image_array[0]) * len(histo.image_array)
    return np.concatenate([rg_bins[0],by_bins[0],wb_bins[0]])/total_pixel

def offline(database):
    """
    ===========================================================================
    This function will create the histograms's bins of each image in
    the database, then save the sorted vector
    ===========================================================================
    Argument : 
        database : the database containing all the pictures used as models
    Return :
        None
    """
    assert type(database) is Database

    # ---- Off-line phase ----

    #Check in database if all histograms are created
    #If not create it
    database._calculate_histograms()

    # -- Create the vectors -- 

    #Prepare the directory where the bins_histograms are saved
    dir = os.path.dirname(database)
    path = os.path.join(dir,'bins_histogram' ) 
    if not os.path.exists(path):
        os.makedirs(path)

    histos = database.histograms()
    for model in histos :
        histo = model[1]
        image_name = model[0].split("\\")[-1] #retrieve original image name
        tmp_vector = color_axes(histo)

        #Pickling/saving the compressed vector
        with open(path+"\""+image_name, "wb") as fp:   
            pickle.dump(tmp_vector, fp)
    

def increment(histo_image, database, bins_to_compare = 10, n_best = 5) :
    """
    ===========================================================================
    This function apply the incremental intersection of a histogram image 
    to a set of already calculated vector
    ===========================================================================
    Arguments : 
        histo_image : the Histogram object of the image
        database : the database object
        bins_to_compare : the number of bins to compare.
                          By default, it's equal to 10.
    Return : 
        A list of the N best images matches
    """
    assert type(histo_image) is Histogram
    assert type(database) is Database
    assert type(bins_to_compare) is int
    assert type(n_best) is int

    # ---- On-line phase ----

    new_histo = color_axes(histo_image)
    matched = []
    
    #Sorts the bins by size while retaining index
    histo_image_sorted=[]
    histo_image_sorted.append(np.sort(new_histo,kind='mergesort'))
    histo_image_sorted.append(np.argsort(new_histo,kind='mergesort'))
    
    #new_histo_sorted = [ [list_of_values] , [list_of_original_index] ]

    number_to_compare = {bins_to_compare
                         if bins_to_compare <= len(histo_image_sorted[0])
                         else len(histo_image_sorted[0])}.pop()
    
    for bin in range(number_to_compare) : 
        current_bin = histo_image_sorted[0][-bin]
        index =  histo_image_sorted[1][-bin]#index  of the current bins

        #Match current_bin with bin of model with same index if key is 
        #larger than current_bin
        #Implementation differs depending on how histo_model is created

        for hist in os.listdir("Database"+os.sep+"histo_bins"+os.sep):
            #TODO code might be wrong 
            if current_bin < hist[index] :
                if hist not in matched : 
                    matched.append(hist)
    
    return matched
    #Apply sort on the matched to get direct best matches?
    pass

def incremental_intersection(histo_image, histo_model, bins_to_compare = 10 ):
    """
    ===========================================================================
    This function calculates the intersection of two histograms,
    evaluating only the largest bins of the histograms
    ===========================================================================
    Arguments : 
        histo_image : the Histogram object of the image
        histo_model : the Histogram object of the model
        bins_to_compare : the number of bins to compare.
                          By default,it's equal to 10.
    """
    assert type(histo_image) is Histogram
    assert type(histo_model) is Histogram
    
    pass

    # ---- On-line phase ----

    new_histo = color_axes(histo_image)
    matched = []
    
    #Sorts the bins by size while retaining index
    histo_image_sorted=[]
    histo_image_sorted.append(np.sort(new_histo,kind='mergesort'))
    histo_image_sorted.append(np.argsort(new_histo,kind='mergesort'))
    
    #new_histo_sorted = [ [list_of_values] , [list_of_original_index] ]

    number_to_compare = {bins_to_compare 
                         if bins_to_compare<= len(histo_image_sorted[0]) 
                         else len(histo_image_sorted[0])}
    for bin in range(number_to_compare) : 
        current_bin = histo_image_sorted[0][-bin]
        index =  histo_image_sorted[1][-bin]#index  of the current bins

        #Match current_bin with bin of model with same index if key 
        #is larger than current_bin
        #Implementation differs depending on how histo_model is created
        for hist in histo_model :
            if current_bin < hist[index] :
                if hist not in matched : 
                    matched.append(hist)
    
    return matched
    #Apply sort on the matched to get direct best matches?



    """
    offline
    take all img from database
    create histo all of it
    assign key to each bins
        ==> calculate nb pixel
        use double list ?
        can a bin have same key as another one

    group bins by index color
        color are the color axes rg wb by
        3 groups
    
    Sort each group by key
        ex rg wb by
        ou wb by rg
        ou rg by wb

    
    online
    trier les bins de notre image  en decroissant
    pour les B plus grands  bins commancant par les + grands
    Faire correspondre ceux qui ont le même index couleur 
    et qui ont la plus grosse clé
    """

def jaccard_index(data1, data2) -> float :
    """
    ===========================================================================
    This function calculate the Jaccard index of 2 sets
    ===========================================================================
    Argument : 
        data1 : a set of data
        data2 : a set of data
    Return :
        The Jaccard index of the two given set
    """
    assert type(data1) is set
    assert type(data2) is set
    intersect = set.intersection(data1,data2)
    jaccard_index = len(intersect) / (len(data1)+len(data2)-len(intersect))

    #jaccard_distance = 1 - jaccard_index
    return jaccard_index

def retrieval(depth=15):
    """
    ===========================================================================
    This function calculates the closest matching images in the database.
    It returns as many images as the value of depth argument
    ===========================================================================
    """
    assert type(depth) is int

def label_images(img):
    """
    ===========================================================================
    This function is a labelling of a given image according to potential(s)
    caracteristic(s)
    ===========================================================================
    """
    assert type(img) is Image

def cluster(db):
    """
    ===========================================================================
    Groups the images in the database according to the labels that have been
    assigned to them
    ===========================================================================
    """
    assert type(db) is Database

def _add_database():
    """
    ===========================================================================
    If the no_add argument of the application is false, this function is called
    then calls the add function of Database to add each image and its color
    histogram to the database
    ===========================================================================
    """


#if __name__ == "__main__":
#    print("pouf")
#    gris = Histogram(Image("UnitTesting/Histogram/green_square.png"))
#    h = Histogram(Image("UnitTesting/Image/image1.jpg"))
#    g = Histogram(Image("UnitTesting/Image/image2.jpg"),bins =255,grey = True)
#    print((intersection(gris, g)))
#    print(ColorHistogram.transformation_grey(h))
#    print(intersection(gris, h))

#if __name__ == "__main__":
#    assert os.path.exists("UnitTesting/Image/image1.jpg")
#    test1 = Histogram(Image("UnitTesting/Image/image1.jpg"))
#    print(color_axes(test1))