#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
import ctypes

def Mbox(title, text, style):
    return ctypes.windll.user32.MessageBoxW(0, text, title, style)

from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use("TkAgg")
import os
import numpy as np
import tkinter as tk
from tkinter import filedialog
from tkinter import DISABLED, NORMAL
from tkinter import TOP, LEFT
from PIL import ImageTk
import tkinterdnd2 as tkd
import CorruptedException as ce
from Image import Parser, Image, check_extension
from Histogram import Histogram, ColorHistogram, GreyHistogram
from tkinter import ttk
from CLI import CLI
from re import match
import pickle

BLANK_FIG = Figure()

if sys.version_info < (3,0):
    print("This program runs under python 3 or more. To use it please get"+
          " you version of python up to date.")
    Mbox("Errors", "This program runs under python 3 or more. To use it"+
         " please get you version of python up to date.")

class CanvasDnD(tk.Canvas):
    def load_image(self, event, app):
        filename = str(event.data).replace("{", "").replace("}", "")
        self.load_image_file(filename, app);
        
    def _check_file(file):
        assert check_extension(file)
        try:
            with Image(file).getimg() as img:
                img.verify()
            return(True)
        except:
            raise ce.CorruptedFileException("The file given seems corrupted.")
    
    def load_image_file(self, Sfile, app):
        assert CanvasDnD._check_file(Sfile)
        app.cli._args.image = Image(Sfile)
        self.img = Image(Sfile)
        tkimg = Parser.scale_image(self.img)
        self.tkImg = ImageTk.PhotoImage(tkimg)
        self.config(height = self.tkImg.height(), width = self.tkImg.width())
        self.create_image(self.tkImg.width(), self.tkImg.height(), 
                          image = self.tkImg, anchor = tk.SE)
        app.show_hist1()
    
    def load_image_selection(self, app):
        """
        This method is the one used by the button open (for the files)
        on the GUI.
        It opens a window allowing the user to browse its file and then reads 
        and load the selected file.
        """
        typeslist = [("IMG file", ".img"), ("JPG file", ".jpg"), 
                     ("PNG file", ".png"), ("PDF file", ".pdf"), 
                     ("GIF file", ".gif"), ("BITMAP", ".bmp"),
                     ("JPEG file", ".jpeg"), ("*", ".*")]
        Sfile = filedialog.askopenfilename(title = "SÃ©lectionnez un fichier", 
                                           filetypes = typeslist)
        if Sfile != "":
            self.load_image_file(Sfile, app)
        
class HelpWindow():
    def __init__(self, app, directory = "./options"):
        assert isinstance(app, Application) 
        self.dir = directory
        self.word_list = [x[:x.index(".help")] for x in os.listdir(self.dir) 
                          if x.endswith(".help")]
        self.application = app
        self.helpWindow = tk.Tk()
        self.helpWindow.title("help")
        self.helpWindow.geometry("686x480")
        self.helpWindow.config(bg = "#111111")
        self.help_frame = tk.Frame(self.helpWindow, 
                                   height = 30, 
                                   width = 86)
        self.help_frame.pack()
        self.accepted_help_text = tk.Text(self.help_frame, 
                                          height = 4, 
                                          width = 84)
        self.accepted_help_text.pack(side = TOP)
        self.help_text = tk.Text(self.help_frame, 
                                 height = 28, 
                                 width = 84, 
                                 state = DISABLED)
        self.box_frame = tk.Frame(self.help_frame, 
                                     height = 5, 
                                     width = 84)
        self.box_frame.pack(side = TOP)
        self.word_box = ttk.Combobox(self.box_frame, 
                                  values = self.word_list,
                                  state = "readonly")
        self.word_box.bind("<<ComboboxSelected>>", self.words_help)
        self.word_box.pack(side = TOP)
        self.help_text.pack(side = TOP)
        self.accepted_help_text.insert("end", "The help about technical terms"+
                    " about the segmentation of an image based on a compact\n"+
                    "representation of the color histogram.\n")
        self.accepted_help_text["state"] = DISABLED
        self.helpWindow.protocol("WM_DELETE_WINDOW", 
                                 self.on_closing_help)
    def words_help(self, event):
        word = self.word_box.get()
        self.help_text["state"] = NORMAL
        self.help_text.delete("1.0", "end")
        with open(self.dir + "/" + word + ".help", "r") as help_file:
            self.help_text.insert("end", help_file.read())
        self.help_text["state"] = DISABLED
    def on_closing_help(self):
        self.application.helpWindow = None
        self.application.helpOpen = False
        self.helpWindow.destroy()
        del(self)
    def lift(self):
        self.helpWindow.lift()
        self.helpWindow.focus_force()
        self.helpWindow.grab_set()
        self.helpWindow.grab_release()
        
class Application:
    
    def on_closing(self):
       """
       This is the closing protocol, it is activated on the closing of the 
       main window.
       Its purpose is to delete every temporary file that has been created 
       during the session and then to destroy the window.
       """
       if self.helpOpen:
           self.helpWindow.on_closing_help()
       for file in os.scandir(self.tmpPath):
           os.remove(file)
       os.rmdir(self.tmpPath)
       self.window.destroy()
       self.window.quit()
                
    def show_help(self):
        if(self.helpOpen):
            self.helpWindow.lift()
        else:
            self.helpOpen = True
            self.helpWindow = HelpWindow(self)
            self.helpWindow.lift()
    
    def save():
        return()
    
    def compute():
        return()
    
    def parse_background_color(self) -> str:
        """
        =======================================================================
        This method is the parser for default value of the attribute database.
        It is called when the --database or -db argument is not used.
        It finds the default value in the self.default file.
        =======================================================================
        Returns:
            Integer stated in the self.default file.
            255 if the default value is None 
            (255 is the default value at initialisation of the Application)
        """
        for s in self.cli.default:
            if match(r"background_color", s):

                if s.endswith("None"):
                    return("#000000")
                else:
                    return(str(s[s.index("=")+1:].strip()))
    
    def show_hist1(self):
        if self.hist1_check_value.get() == 1 and self.cli._args.image != None:
            if self.figure == BLANK_FIG:
                self.figure = plt.figure(dpi = 300)
            plt.clf()
            imgpath = self.cli._args.image.getpath()
            filename = self.cli._args.image.getpath()[imgpath.rindex("/")+1:
                                imgpath.index(".")]
            if os.path.exists(self.tmpPath +f"/Hist{filename}.png"):
                plt.close()
                with open(self.tmpPath+f"/Hist{filename}.hist", "rb") as file:
                    self.histo = pickle.load(file)
            else:
                self.histo = Histogram(self.cli._args.image)
                
                if isinstance(self.histo, ColorHistogram):
                    plt.hist(self.histo.get_red())
                    plt.hist(self.histo.get_green())
                    plt.hist(self.histo.get_blue())
                elif isinstance(self.histo, GreyHistogram):
                    plt.hist(self.histo.get_grey())
                    
                plt.show()
                plt.draw()    
                plt.rcParams["figure.figsize"] = (5,4.5)
            
                with open(self.tmpPath+f"/Hist{filename}.hist", "wb") as file:
                    pickle.dump(self.histo, file, 
                                protocol=pickle.HIGHEST_PROTOCOL)
                plt.savefig(self.tmpPath +f"/Hist{filename}.png", format="PNG")
        else:
#                filename = self.cli._args.image.getpath()[:
#                                    self.cli._args.image.getpath().index(".")]
#                if os.path.exists(self.tmpPath + f"/Hist{filename}.png"):
#                    os.remove(self.tmpPath + "/Hist{filename}.png")
                plt.close()
    
    def __init__(self, options = "./options/CLI.init"):
                
        self.tmpPath = "temp"
        while os.path.exists(self.tmpPath):
            self.tmpPath += "p"
        os.mkdir(self.tmpPath)
        
        self.cli = CLI(default_dir=options[:options.rindex("/")], 
            default_file = options[options.rindex("/")+1:])
        
        self.window = tkd.TkinterDnD.Tk()
        self.window.title('Application')
        self. window.geometry('750x800')
        self.window.config(bg = self.parse_background_color())
        
        self.ws = tk.Frame(self.window)
        self.ws.pack(side = TOP)
        
        self.frame = tk.Frame(self.ws, height = 60, width = 82)
        self.frame.pack(side = TOP)
        
        self.optionFrame = tk.Frame(self.frame, height = 10, width = 40)
        self.optionFrame.pack(side = TOP)
        
        self.frameDnD = tk.Frame(self.frame, height = 23, width = 41)
        self.frameDnD.pack(side = LEFT)
        
        self.computeFrame = tk.Frame(self.ws)
        self.computeFrame.pack(side = TOP)
        
        self.window.lift()
        self.window.focus_force()
        self.window.grab_set()
        self.window.grab_release()
        
        self.image = self.cli._args.image
        self.figure = Figure()
        self.helpOpen = False
        
        self.canvas = CanvasDnD(self.frameDnD, height=250, width=500)
        self.canvas.grid(row = 1, column = 0, rowspan = 3, columnspan = 6)
        self.canvas.drop_target_register(tkd.DND_FILES)
        self.canvas.dnd_bind('<<Drop>>', lambda x:
                                        self.canvas.load_image(x,self))
        
        if self.image != None:
            self.canvas.load_image_file(self.image.getpath())
        
        self.open_button = tk.Button(self.frameDnD, 
                                activebackground = "blue", 
                                bg = "white", 
                                text = "open", 
                                command = lambda :
                                        self.canvas.load_image_selection(self))
        self.open_button.grid(row = 7, column = 0, columnspan = 6)
        
        self.hist1_check_value = tk.IntVar()
        self.hist1_check = tk.Checkbutton(self.frameDnD, 
                                     disabledforeground = "yellow", 
                                     text = "see the histogram", 
                                     variable = self.hist1_check_value, 
                                     command = self.show_hist1, 
                                     onvalue = 1)
        self.hist1_check.grid(row = 7, column = 0)
        
        self.help_option = tk.Button(self.optionFrame, 
                                activebackground = "red", 
                                bg = "white", 
                                text = "Help", 
                                command = self.show_help)
        self.help_option.pack(side = LEFT)
        
        self.save_option = tk.Button(self.optionFrame, 
                                activebackground = "blue", 
                                bg = "white", 
                                text = "save", 
                                command = self.save)
        self.save_option.pack(side = LEFT)
        
        self.compute_button = tk.Button(self.computeFrame, 
                                   height = 8, 
                                   width = 68, 
                                   text = "COMPUTE", 
                                   activebackground = "yellow", 
                                   bg = "blue", 
                                   command = self.compute)
        self.compute_button.pack(side = TOP)

        self.result_canvas = CanvasDnD(self.computeFrame, 
                                       height = 240, 
                                       width = 500)
        self.result_canvas.pack(side = TOP)
        self.result_canvas.drop_target_register(tkd.DND_FILES)
        self.result_canvas.dnd_bind('<<Drop>>', self.result_canvas.load_image)
        
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        self.window.title("Segmentation tool")
        
        self.window.mainloop()

if __name__ == "__main__":
    a = Application()
    del(a)